# Java 核心技术 卷I - 第七章

## 7.1 - 处理错误

假设在一个Java程序运行期间出现了一个错误:

这个错误可能时由于文件包含了错误的信息,或者网络连接出现问题造成的,也有可能因为使用无效的数值下标,或者试图使用一个没有被赋值的对象引用而造成的

用户期望在出现错误时,程序能够采用一些理智的行为.如果由于出现错误而使得某些操作没有完成,程序应该:

 - 返回到一种安全状态,并能够让用户执行一些其他的命令
 - 或者允许用户保存所有操作的结果,并以妥善的方式终止程序

要做到这些并不是一件很容易的事情

其原因是**检测(或引发)错误条件的代码通常离那些能够让数据恢复到安全状态,或者能够保存用户的操作结果,并正常地退出程序的代码很远**.

**异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器**

> 在Java中,如果某个方法不能够采用正常的途径完整的完成它的任务,就可以通过另外一个路径退出方法
> 
> **在这种情况下,方法并不返回任何值,而是抛出`throw`一个封装了错误信息的对象.需要注意的是,这个方法将会立刻退出,并不返回任何值**
>
> **此外,调用这个方法的代码也将无法继续执行,取而代之的是,异常处理机制开始搜索能够处理这种异常状况的异常处理器**

### 7.1.1 - 异常分类

**在Java中,异常对象都是派生域`Throwable`类的一个实例**

Java异常层次简化结构如下:
    
             Throwable
      ┌──────────┴───────────┐
    Error                 Exception
                    ┌─────────┴──────────┐
                IOException     RuntimeException

需要注意的是,**所有的异常都是有`Throwable`继承而来**,但是下一层立即分解为两个分支: `Error`和`Exception`

**`Error`类层次结构描述了程序运行时系统的内部错误和资源耗尽错误.程序不应该抛出这种类型的对象**
 
 - 如果出现这种的内部错误,除了通告给用户,并尽力的使程序安全的终止之外,再也无能为力了.但是这种情况一般很少出现

而我们更需要关注`Exception`层次结构.这个层次结构又有两个分支: 一个分支派生于`RuntimeException`,并一个分支包含其他异常

 - 划分两个分支的规则是: **由程序错误导致的异常属于`RuntimeException`**;**而程序本身没有问题,但由于像I/O错误这种问题导致的异常属于其他异常** 

派生于`RuntimeException`的异常包含下面几种情况:

 - **错误的类型转换**
 - **数组访问越界**
 - **访问`null`指针**

不是派生于`RuntimeException`的异常包含:

 - **试图在文件尾部后面读取数据**
 - **试图打开一个不存在的文件**
 - **试图根据给定的字符串查找`Class`对象,而这个字符串表示的类不存在**

**如果出现`RuntimeException`异常,那么就一定是你的问题**,这是一条相当有道理的规则.

> Java将派生于`Error`类或`RuntimeException`类的所有异常称为非受检查异常,所有其他的异常称为受查异常

### 7.1.2 - 声明受查异常

如果遇到了无法处理的情况,Java的方法可以抛出一个异常

这个道理很简单: **一个方法不仅需要告诉编译器将要返回什么值,还要告诉编译器有可能发生什么错误**

例如,一段读取文件的代码知道有可能读取的文件不存在,获取内容为空

 - 因此,试图处理文件信息的代码就需要通知编译器可能会抛出`IOException`类的异常

方法应该在其首部声明所有可能抛出的异常.这样可以从首部方法出这个方法可能抛出哪类受查异常.例如:

```java
public static Class<?> forName(String className) throws ClassNotFoundException 
```

> 这个声明表示这个方法将根据给定的`String`参数产生一个`Class`对象,但也有可能抛出一个`ClassNotFoundException`异常
>
> 如果发生了这种糟糕的情况,构造器将不会初始化一个新的`Class`对象,而是抛出一个`ClassNotFoundException`类对象
>
> 如果这个方法方法真的抛出了这样一个异常对象,运行时系统就会开始搜索异常处理器,以便知道如何处理`ClassNotFoundException`

**在自己编写方法时,不必将所有可能抛出的异常都进行声明**

至于什么时候需要在方法中用`throws`子句声明异常,什么异常必须使用`throws`子句声明,需要记住在遇到下面4种情况时应该抛出异常:

 1. **调用一个抛出受查异常的方法**,例如: FileInputStream构造器
 
 2. **程序运行过程中发现错误**,并且利用`throw`语句抛出一个受查异常
 
 3. **程序出现错误**,例如: `a[-1] =0`会抛出一个`ArrayIndexOutBoundsException`这样的非受查异常
 
 4. **Java虚拟机和运行时库出现的内部错误**

如果出现前两种情况之一,则必须告诉调用方有可能抛出的异常.为什么要这么做?
  
  - 因为任何一个抛出异常的方法都有可能是一个死亡陷阱,如果没有处理器捕获这个异常,当前执行的线程就会结束
 
**对于那些可能被他人使用的方法,应该根据异常规范在方法的首部声明这个方法可能抛出的异常**

```java
public static Class<?> forName(String className) throws ClassNotFoundException
```

如果一个方法有可能抛出多个受查异常类型,那么就必须在方法的首部列出所有的异常类,每个异常类之间用逗号隔开.例如:

```java
public T newInstance() throws InstantiationException, IllegalAccessException
```

但是,不需要声明Java的内部错误,就是从`Error`继承的错误.任何程序代码都具有抛出那些异常的潜能,而我们对其没有任何控制能力
 
同样,也不应该声明从`RuntimeException`继承的那些非受检查的异常,因为这些运行时错误完全在我们的控制之下.

```java
// NullPointerException 继承于 RuntimeException
public void print() throws NullPointerException
```

**如果特别关注数组下标引发的错误,就一个将更多的时间花费在修正程序中的错误上,而不是说明这些错误发生的可能性上**

> 总之,一个方法必须声明所有可能抛出的受查异常,而非受查异常要么不可控制(Error),要么就应该避免发生(RuntimeException)
>
> 如果方法没有声明所有可能发生的受查异常,编译器将会发出错误信息

### 7.1.3 - 抛出异常

### 7.1.4 - 创建自定义异常

## 7.2 - 捕获异常

## 7.3 - 使用异常机制的技巧
