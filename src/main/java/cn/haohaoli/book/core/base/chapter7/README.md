# Java 核心技术 卷I - 第七章

## 7.1 - 处理错误

假设在一个Java程序运行期间出现了一个错误:

这个错误可能时由于文件包含了错误的信息,或者网络连接出现问题造成的,也有可能因为使用无效的数值下标,或者试图使用一个没有被赋值的对象引用而造成的

用户期望在出现错误时,程序能够采用一些理智的行为.如果由于出现错误而使得某些操作没有完成,程序应该:

 - 返回到一种安全状态,并能够让用户执行一些其他的命令
 - 或者允许用户保存所有操作的结果,并以妥善的方式终止程序

要做到这些并不是一件很容易的事情

其原因是**检测(或引发)错误条件的代码通常离那些能够让数据恢复到安全状态,或者能够保存用户的操作结果,并正常地退出程序的代码很远**.

**异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器**

> 在Java中,如果某个方法不能够采用正常的途径完整的完成它的任务,就可以通过另外一个路径退出方法
> 
> **在这种情况下,方法并不返回任何值,而是抛出`throw`一个封装了错误信息的对象.需要注意的是,这个方法将会立刻退出,并不返回任何值**
>
> **此外,调用这个方法的代码也将无法继续执行,取而代之的是,异常处理机制开始搜索能够处理这种异常状况的异常处理器**

### 7.1.1 - 异常分类

**在Java中,异常对象都是派生域`Throwable`类的一个实例**

Java异常层次简化结构如下:
    
             Throwable
      ┌──────────┴───────────┐
    Error                 Exception
                    ┌─────────┴──────────┐
                IOException     RuntimeException

需要注意的是,**所有的异常都是有`Throwable`继承而来**,但是下一层立即分解为两个分支: `Error`和`Exception`

**`Error`类层次结构描述了程序运行时系统的内部错误和资源耗尽错误.程序不应该抛出这种类型的对象**
 
 - 如果出现这种的内部错误,除了通告给用户,并尽力的使程序安全的终止之外,再也无能为力了.但是这种情况一般很少出现

而我们更需要关注`Exception`层次结构.这个层次结构又有两个分支: 一个分支派生于`RuntimeException`,并一个分支包含其他异常

 - 划分两个分支的规则是: **由程序错误导致的异常属于`RuntimeException`**;**而程序本身没有问题,但由于像I/O错误这种问题导致的异常属于其他异常** 

派生于`RuntimeException`的异常包含下面几种情况:

 - **错误的类型转换**
 - **数组访问越界**
 - **访问`null`指针**

不是派生于`RuntimeException`的异常包含:

 - **试图在文件尾部后面读取数据**
 - **试图打开一个不存在的文件**
 - **试图根据给定的字符串查找`Class`对象,而这个字符串表示的类不存在**

**如果出现`RuntimeException`异常,那么就一定是你的问题**,这是一条相当有道理的规则.

> Java将派生于`Error`类或`RuntimeException`类的所有异常称为非受检查异常,所有其他的异常称为受查异常

### 7.1.2 - 声明受查异常

如果遇到了无法处理的情况,Java的方法可以抛出一个异常

这个道理很简单: **一个方法不仅需要告诉编译器将要返回什么值,还要告诉编译器有可能发生什么错误**

例如,一段读取文件的代码知道有可能读取的文件不存在,获取内容为空

 - 因此,试图处理文件信息的代码就需要通知编译器可能会抛出`IOException`类的异常

方法应该在其首部声明所有可能抛出的异常.这样可以从首部方法出这个方法可能抛出哪类受查异常.例如:

```java
public static Class<?> forName(String className) throws ClassNotFoundException 
```

> 这个声明表示这个方法将根据给定的`String`参数产生一个`Class`对象,但也有可能抛出一个`ClassNotFoundException`异常
>
> 如果发生了这种糟糕的情况,构造器将不会初始化一个新的`Class`对象,而是抛出一个`ClassNotFoundException`类对象
>
> 如果这个方法方法真的抛出了这样一个异常对象,运行时系统就会开始搜索异常处理器,以便知道如何处理`ClassNotFoundException`

**在自己编写方法时,不必将所有可能抛出的异常都进行声明**

至于什么时候需要在方法中用`throws`子句声明异常,什么异常必须使用`throws`子句声明,需要记住在遇到下面4种情况时应该抛出异常:

 1. **调用一个抛出受查异常的方法**,例如: FileInputStream构造器
 
 2. **程序运行过程中发现错误**,并且利用`throw`语句抛出一个受查异常
 
 3. **程序出现错误**,例如: `a[-1] =0`会抛出一个`ArrayIndexOutBoundsException`这样的非受查异常
 
 4. **Java虚拟机和运行时库出现的内部错误**

如果出现前两种情况之一,则必须告诉调用方有可能抛出的异常.为什么要这么做?
  
  - 因为任何一个抛出异常的方法都有可能是一个死亡陷阱,如果没有处理器捕获这个异常,当前执行的线程就会结束
 
**对于那些可能被他人使用的方法,应该根据异常规范在方法的首部声明这个方法可能抛出的异常**

```java
public static Class<?> forName(String className) throws ClassNotFoundException
```

如果一个方法有可能抛出多个受查异常类型,那么就必须在方法的首部列出所有的异常类,每个异常类之间用逗号隔开.例如:

```java
public T newInstance() throws InstantiationException, IllegalAccessException
```

但是,不需要声明Java的内部错误,就是从`Error`继承的错误.任何程序代码都具有抛出那些异常的潜能,而我们对其没有任何控制能力
 
同样,也不应该声明从`RuntimeException`继承的那些非受检查的异常,因为这些运行时错误完全在我们的控制之下.

```java
// NullPointerException 继承于 RuntimeException
public void print() throws NullPointerException
```

**如果特别关注数组下标引发的错误,就一个将更多的时间花费在修正程序中的错误上,而不是说明这些错误发生的可能性上**

> 总之,一个方法必须声明所有可能抛出的受查异常,而非受查异常要么不可控制(Error),要么就应该避免发生(RuntimeException)
>
> 如果方法没有声明所有可能发生的受查异常,编译器将会发出错误信息

### 7.1.3 - 抛出异常

`print()`方法用于打印一个字符.然而我们希望参数不为空,如果为空我们认为这是一种不正常的情况,希望抛出(`throw`)一个异常

但是首先要决定应该抛出什么类型的异常,将上述异常归结为`RuntimeException`是一种很好的选择

```java
/**
 * @param
 * @throws NullPointerException
 */
public void print (String str) {
    if (null == str) {
        throw new NullPointerException();
    }
    System.out.print(str);
}
```

> 可以将方法中抛出的(非检查)异常在注释`@throws`中标明,提高可读性

对于一个已经存在的异常我们只需要,找到合适的异常类然后创建该类的对象将其抛出

**一旦方法抛出了异常,这个方法就不可能返回到调用者.也就是说,不必为返回的默认值或错误代码担忧**

### 7.1.4 - 创建自定义异常

在程序中,可能会遇见任何标准异常类都没有能够充分描述清楚的问题,在这种情况下,创建自己的异常类就是一件顺理成章的事情了

我们只需要定义一个派生于`Exception`或是派生于`Exception`子类的类

例如,定义一个派生于`RuntimeException`的类

```java
public class PrintException extends RuntimeException {
    
    public PrintException(){
    }

    public PrintException(String message) {
        super(message);
    }
}
```

**习惯上,定义的类应该包含两个构造器,一个是默认构造器;另一个是带有详细描述信息的构造器**

 - 超类`Throwable`的`toString`方法会打印这些详细信息,这在调试中非常有用

现在就可以抛出自己定义的异常类型了

```java
/**
 * @param
 * @throws PrintException
 */
public void print (String str) {
    if (null == str) {
        throw new PrintException();
    }
    System.out.print(str);
}
```

## 7.2 - 捕获异常

我们已经知道了如果抛出一个异常.这个过程十分的简单.只要将其抛出就不用理了,但是有些代码必须捕获异常

如果某个异常发生的时候没有在任何地方进行捕获,那程序就会终止执行,并在控制台上打印异常信息,其中包含异常的类型和堆栈内容

想要捕获一个异常,必须设置`try/catch`语句块.例如:

```java
try {
    // 代码
} catch (Exception e){
    // 处理语句
}
```

如果在`try`语句块中任何代码抛出了一个在`catch`子句中的异常类,那么:

1. 程序将跳过`try`语句块的其余代码

2. 程序将执行`catch`子句中的代码

**如果在`try`语句块中的代码没有抛出任何异常,那么程序将跳过`catch`子句**

**如果方法中的任何代码抛出了一个在`catch`子句中没有声明的异常类型,那么这个方法就会立即退出**

### 7.2.2 捕获多个异常

在一个`try`语句块中可以捕获多个异常类型,并对不同类型的异常做出不同的处理.可以按照下列方法为每个异常类型使用一个独立的`catch`子句

```java
try {
    // 代码
} catch (FileNotFoundException e) {
    // 处理语句
} catch (IoException e) {
    // 处理语句
}
```

> 异常对象可能包含于异常本身有关的信息,要获取对象的更多信息,可以使用`e.getMessage()`

在JDK7中,同一个`catch`子句中可以捕获多个异常类型

```java
try {
    // 代码
} catch (FileNotFoundException | NullPointerException e ) {
    // 处理语句
}
```

## 7.3 - 使用异常机制的技巧
