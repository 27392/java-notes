# Java 核心技术 卷I - 第七章

## 7.1 - 处理错误

假设在一个Java程序运行期间出现了一个错误:

这个错误可能时由于文件包含了错误的信息,或者网络连接出现问题造成的,也有可能因为使用无效的数值下标,或者试图使用一个没有被赋值的对象引用而造成的

用户期望在出现错误时,程序能够采用一些理智的行为.如果由于出现错误而使得某些操作没有完成,程序应该:

 - 返回到一种安全状态,并能够让用户执行一些其他的命令
 - 或者允许用户保存所有操作的结果,并以妥善的方式终止程序

要做到这些并不是一件很容易的事情

其原因是**检测(或引发)错误条件的代码通常离那些能够让数据恢复到安全状态,或者能够保存用户的操作结果,并正常地退出程序的代码很远**.

**异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器**

> 在Java中,如果某个方法不能够采用正常的途径完整的完成它的任务,就可以通过另外一个路径退出方法
> 
> **在这种情况下,方法并不返回任何值,而是抛出`throw`一个封装了错误信息的对象.需要注意的是,这个方法将会立刻退出,并不返回任何值**
>
> **此外,调用这个方法的代码也将无法继续执行,取而代之的是,异常处理机制开始搜索能够处理这种异常状况的异常处理器**

### 7.1.1 - 异常分类

**在Java中,异常对象都是派生域`Throwable`类的一个实例**

Java异常层次简化结构如下:
    
             Throwable
      ┌──────────┴───────────┐
    Error                 Exception
                    ┌─────────┴──────────┐
                IOException     RuntimeException

需要注意的是,**所有的异常都是有`Throwable`继承而来**,但是下一层立即分解为两个分支: `Error`和`Exception`

**`Error`类层次结构描述了程序运行时系统的内部错误和资源耗尽错误.程序不应该抛出这种类型的对象**
 
 - 如果出现这种的内部错误,除了通告给用户,并尽力的使程序安全的终止之外,再也无能为力了.但是这种情况一般很少出现

而我们更需要关注`Exception`层次结构.这个层次结构又有两个分支: 一个分支派生于`RuntimeException`,并一个分支包含其他异常

 - 划分两个分支的规则是: **由程序错误导致的异常属于`RuntimeException`**;**而程序本身没有问题,但由于像I/O错误这种问题导致的异常属于其他异常** 

派生于`RuntimeException`的异常包含下面几种情况:

 - **错误的类型转换**
 - **数组访问越界**
 - **访问`null`指针**

不是派生于`RuntimeException`的异常包含:

 - **试图在文件尾部后面读取数据**
 - **试图打开一个不存在的文件**
 - **试图根据给定的字符串查找`Class`对象,而这个字符串表示的类不存在**

**如果出现`RuntimeException`异常,那么就一定是你的问题**,这是一条相当有道理的规则.

> Java将派生于`Error`类或`RuntimeException`类的所有异常称为非受检查异常,所有其他的异常称为受查异常

### 7.1.2 - 声明受查异常

### 7.1.3 - 抛出异常

### 7.1.4 - 创建自定义异常

## 7.2 - 捕获异常

## 7.3 - 使用异常机制的技巧
